Simplified how to manual for REDBASE parser modifications

This is a bottom up approach to adding functionality to the parser.  It
helps, before you start, if you've already decided on the syntax of your
additions.

In brief, once you have a high level definition of your additions, go
about achieving the functionality starting from the foundations.

Start by considering which keywords you want to add to to the language.
These are be tokenized by lex.

1.  scan.l
    This is the lexer proper.  You probably don't need to change
    anything here.

    The idea behind its operation, however, is the following:
	the left column corresponds to patterns that the lexer will find
	in the strings it processes, and the right column indicates what
	actions the lexer takes when the corresponding pattern is found.

    The most important lexer entry in scan.l looks like this:

	{letter}({letter}|{digit}|_)*	{return get_id(yylval.sval = yytext):}

    A letter followed by any combination of letters, numbers and underscore
    characters is an identifier, and the lexer calls get_id() to figure out
    which one it is.

2.  scanhelp.c
    This contains the get_id() function.  It checks the identifier
    against all of the possible keywords it knows, and if it finds it,
    returns the corresponding token, otherwise it returns a stored copy
    of the string to be parsed.

    There are also utilities that remove quotes from strings, store copies
    of them in a memory pool (the strings that are passed as parameters to
    the DM and QL functions are stored here), but they don't need changing.

3.  parser_internal.h
    This begins with a list of the types of commands and their components.
    Each component must also be stored, and parse.h defines as nodes these
    storage types.  If you are adding commands that have a different form
    than the already extant ones, you will need to add to this enumeration,
    and probably define a new kind of data node, to allow the parser to
    build the command correctly.

4.  nodes.c
    If you define new node types in parser_internal.h, then you can write code
    to initialize them and add it to nodes.c which is very straightforward
    given the multitude of examples of node types already present.

5.  parse.y
    This first defines the types of input it encounters.  At the command
    start the breakdown of the users commands begins.  The most likely spot
    to be changing things is in the command section.

    Essentially, all you do is add a line containing | (logical or)
    and the particular command you designed.

    Somewhere below you define the structure of the command.  The examples
    of these commands show pretty clearly how to go about adding a new one.

    The function RBparse() is also in this file.  Any changes to the overall
    query processing mechanism would be made here.  The function PrintError() 
    is also in this file.

    You don't need to change parse.c, which is automatically generated by
    yacc from parse.y and the header files.  It exists solely to be compiled
    to create the executable code.

6.  interp.c
    Here is where the meat of the interpretation takes place.  When
    a query has been parsed, it sends the resulting node structure --in
    reality, a very simple query tree-- here.  This code simply goes
    through the nodes setting up parameters for the function calls, and
    then calls the user designed and implemented DM and QL functions.


An Example:  adding the command "pack," which takes a relation name and
a percentage as parameters.

scan.l:  no changes

scanhelp.c:  add lines of the type:
	if (!strcmp(string, "pack")) return yylval.ival = RW_PACK

parser_internal.h:  add a type value, node definitions, 
                    and function prototypes:
	N_PACK			/* added to NODEKIND type */

	/* pack node */		/* added to NODE type */
	struct{
	    char *relname;
            int  percentage;
	} PACK;

        NODE *pack_node(char *relname, int percentage);

nodes.c:  add initialization functions:
	NODE *pack_node(char *relname, int percentage)
	{
	    NODE *n = newnode(N_PACK);

	    n -> u.PACK.relname = relname;
	    n -> u.PACK.percentage = percentage;
	    return n;
	}

parse.y:  add parser directions:

	added to token:
		RW_PACK

	added to type <n>:
		pack


	added to utility (or wherever you want):
	  pack
		: RW_PACK T_STRING '(' T_INT ')'
		{
			$$ = pack_node($2, $4);
		}
		;

interp.c:  code to unpack the node and call your Pack() function

    case N_PACK:				/* for Pack() */

	errval = pQlm->Pack(n->u.PACK.relname,
			    n->u.PACK.percentage);
	break;

===========================================================================

How to make the Parser read the input from some file and write the 
output to a file (or do just one of the two). 
The changes required on a file-by-file basis are outlined here: 

1. redbase.cc 
==============

(1.1) Define the input and output file pointers globally (so that they
can be made visible to the parser files through extern declarations). 
For example: 

// the input to the parser comes from the inputFile
FILE * inputFilePtr; 
// the output of the parser goes to the output file 
FILE * outputFilePtr; 

(1.2) Open the files before the call to RBparse() and 
      close them after the call. For example,  

  // be careful with the file paths. Remember that OpenDb() will 
  // change the working directory
  inputFilePtr = fopen("input.dat", "r");
  if(!inputFilePtr) {
    fprintf(stderr, "unable to open input file\n");
    exit(1); 
  }
  
  outputFilePtr = fopen("output.dat", "w");
  if(!outputFilePtr) {
    fprintf(stderr, "unable to open output file\n");
    exit(1); 
  }

  // open the database 
  rc = smm.OpenDb(dbname);
  if(rc) {
    SM_PrintError(rc);
    exit(1);
  }

  // call the command loop
  RBparse(pfm, smm, qlm);
  
  fclose(inputFilePtr);
  fclose(outputFilePtr);


2. scan.l : (input redirection)
===========

(1). Add the following to the first section of the lex file, ie, within
the first %{ ... %}

int my_yyinput(char * buf, int max_size); /* defined in scanhelp.c */
/* Flex uses the macro YY_INPUT to read input data. YY_INPUT needs to be 
*  redefined for input redirection. 
*  For more information please see pages 156-157 of:  
        Lex & Yacc
        by John R. Levine, Tony Mason, Doug Brown
        Reilly & Associates; ISBN: 1565920007
        (Available in the Stanford MATH/CS Library)
*/
#undef YY_INPUT
#define YY_INPUT(buffer, result, max_size) (result = my_yyinput(buffer, max_size))


3. scanhelp.c: (input redirection continued)
===============

1. Define the my_yyinput() function to read from the required input file:

extern FILE* inputFilePtr; 
int my_yyinput(char * buf, int max_size) {
  // read a character from the input file
  char c = (char) fgetc(inputFilePtr);
  // copy it to the buffer
  *buf = c;
  // the number of characters read
  return 1;
}

4. parse.y : (output redirection)
===========

1. In the function RBparse(): 
   
    (1). Disable the printing of the prompt: 

#if 0
      /* Print a prompt */
      cout << PROMPT;

      /* Get the prompt to actually show up on the screen */
      cout.flush(); 
#endif

   (2). Look at the interp(parse_tree) call in the RBparse() function. It is 
      this function which actually interprets each redbase command. 
      The function is defined in interp.c. If you want to do output 
      redirection, you would want to pass the output file pointer
      into this function, which requires changing the function
      definition. Changes are required in 2 places:  

      (2.1). In interp.c itself:  
      // RC interp(NODE *n) {
      RC interp(FILE* fp, NODE *n) {
  
      (2.2). In parser_internal.h:
      // RC   interp(NODE *n);
      RC   interp(FILE * fp, NODE *n);

   3. Pass the output file pointer to the interp() function called from 
      RBparse() 

      /* If a query was successfully read, interpret it */
      if(yyparse() == 0 && parse_tree != NULL)
         if ((rc = interp(outputFilePtr, parse_tree))) {

      Well, for the above to work (ie, for outputFilePtr to be defined 
      in parse.y) you have to add an extern declaration of outputFilePtr 
      in parse.y before its usage:  

      // the output of the parser goes to the output file 
      extern FILE * outputFilePtr; 

5. interp.c (output redirection continued)
============

At this stage you have got the output file pointer into the 
RC interp(FILE* fp, NODE *n) function. Remember, the parameter fp 
points to the output file. All that remains to be done is to 
make changes within interp(FILE* fp, NODE *n) to 
output the required information to the output file. 

A simple change that I made to test out whether all the above stuff 
works is to print out all commands to the output file. For example, 
I added the following line within the case N_CREATETABLE: { .... }

            // I added this statement to print the command to the 
            // output file
            fprintf(fp, "Create Table Command\n");            

%end-of-file 
